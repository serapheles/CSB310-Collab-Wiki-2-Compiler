
A compiler is a software tool created to translate source code written in a high-level programming language into a lower-level programming language or machine code that can be understood by a computer. Its purpose is to annex the gap between the human readable high-level code and machine-readable low-level code. A few steps are needed to create a compiler such as lexical analysis, syntax analysis, semantic analysis, optimization, and code generation. The lexical analysis breaks the source code into a sequence of tokens, such as keywords, identifiers, operators, and constants. Syntax analysis verifies the arrangement of tokens according to grammar rules of the programming language, checking for syntax errors. This step is generated by a parse tree or abstract syntax tree. Semantic analysis checks to ensure the correctness of code semantically. It checks for type compatibility, variable declarations, scoping rules, and other specific rules. Intermediate code generation the compiler generates an intermediate representation of source code, such as an intermediate language or bytecode which is closer to the machine code. Optimization, the compiler applies various techniques to improve efficiency and performance of the generated code. This helps to eliminate unnecessary code, optimizing usage and applying logic and mathematical transformations. Code generation the compiler translates the optimized intermediate code into the target matching code or executable file for a specific hardware platform. 
In the tech world compilers have a long history, dating back to the 50â€™s. The first compiler ever created was the A-0 system and it was completed in 1952 by a team led by Grace Hopper. The A-0 system was a set of instructions that could translate symbolic mathematical code into machine language. In producing A-0, she collected subroutines collected over the years and put them on ta pe. Each routine was given a call number, so that it the machine could find it on the tape. After the A-0 system, Grace and her team developed A-1 and A-2, which were improvements over the A-0. The A-2 compiler was the first ever compiler to be used extensively, making the way for the development of programming languages. Soon after other languages were developed such as FORTRAN developed in 1954 by John Backus at IMB, ALGOL, 1958 developed by an international committee, COBOL developed by Gracie Hopper in 1959, C developed in 1972 by Dennis Ritchie etc. These early developments in compiler technology laid foundation for the modern programming landscape, where compilers continue to be essential tools in software development, enabling programmers to write code in higher-level-languages while generating machine code for various platforms. 
As mentioned above compilers translates a program written in high-level language to machine code. Besides this translation a compiler is also responsible for reporting and handling errors in the programming language, helping to debug, optimizing source code and do all this very fast while preserving the original meaning of the source code. There are various forms of compilers such as, Cross compilers, Incremental compilers, Just in Time compiler (JIT), Threaded code compilers among others. These are also classified regarding how data passes through them like, Single pass compilers, Double pass compilers and multiple pass compilers.  A pass refers to the reading and processing the input. A one pass compiler is simpler to implement. During this pass, the compiler performs lexical analysis, syntax analysis and code generation. This approach implies that the compiler must generate the machine code as it encounters each line of source code. Single-pass compiler are usually less efficient with limited memory. Two pass compilers perform the compilation process in two distinct passes over the source code. During the analysis part, the compiler collects information about the programs structure, resolves forward references and builds symbol table. During the synthesis part, the compiler uses the information collected in the analysis part to generate the final machine code. Multi-pass compilers process source code of a program several times. This contrasts with a one pass compiler. Multi-pass compilers are sometimes called wide compilers, referring to a greater scope of the passes, they can see the entire program being compiled instead of just small portions. These compilers go beyond single-pass and second-pass compilers. Each pass focuses on specific tasks, such as lexical analysis syntax analysis, optimization, and code generation. By dividing the compilation process into multiple passes, each pass can be optimized for its specific task, leading to more efficient and sophisticated compilation. 

Interpreted vs compiled programing languages.

Most programming languages are developed using high-level languages like C, Java, and others. Humans communicate using languages to facilitate effective communication with each other. However, computers operate on a fundamentally different level and understand only numbers. Therefore, computers require a translator to facilitate communication between humans and machines, and this is where interpreters and compilers come into play. 
The main distinction between interpreted and compiled languages lies in the outcome of the interpretation or compilation process. An interpreter directly produces results from a program by reading and executing the source code line by line. In contrast, a compiler translates the source code into a lower-level representation, often assembly language, which is then converted into binary code by an assembler specific to the computer's architecture. Assembly language varies for each computer, depending on its underlying architecture. Consequently, programs written in compiled languages can only run on computers with the same architecture as the one on which they were compiled. While compiled programming languages are not human-readable at the machine level, the source code written in these languages is designed to be easily understood by programmers.
In contrast, interpreted languages do not require a separate compilation step. Instead, an interpreter reads the source code line by line and converts it into either machine code or an intermediate representation. The interpreter directly executes each statement or expression in the source code, producing results as it progresses.
To summarize, interpreters and compilers serve as translators between human-readable programming languages and the machine's language of numbers. Compiled languages result in architecture-specific machine code, while interpreted languages execute the source code directly without prior compilation.

